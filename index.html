<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic Constraint Solver | Digital Twin</title>
    <style>
        :root {
            --bg: #ffffff;
            --text-main: #111;
            --text-sub: #666;
            --line-light: #e0e0e0;
            --mck-blue: #051c2c;
            --accent-alert: #d93025;
            --accent-ok: #188038;
            --accent-warn: #f9ab00;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            width: 100%;
            max-width: 1200px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: 4px solid var(--mck-blue);
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        .title h1 {
            font-family: 'Georgia', serif;
            font-size: 24px;
            margin: 0;
            color: var(--mck-blue);
        }
        
        .title span {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-sub);
        }

        .kpi-row {
            display: flex;
            gap: 40px;
        }

        .kpi {
            text-align: right;
        }
        .kpi-val { font-size: 28px; font-weight: bold; color: var(--mck-blue); }
        .kpi-lbl { font-size: 10px; text-transform: uppercase; color: var(--text-sub); }

        /* MAIN STAGE */
        .stage {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 40px;
            width: 100%;
            max-width: 1200px;
            height: 100%;
        }

        /* CONTROLS */
        .controls {
            border-right: 1px solid var(--line-light);
            padding-right: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;
        }

        .control-group { margin-bottom: 10px; }
        .group-header {
            font-size: 12px; 
            font-weight: bold; 
            margin-bottom: 10px; 
            color: var(--mck-blue);
            border-bottom: 1px solid var(--line-light);
            padding-bottom: 5px;
        }

        .slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        label { font-size: 11px; color: var(--text-sub); }
        .val-disp { font-size: 11px; font-weight: bold; font-family: monospace; }
        
        input[type=range] {
            width: 100%;
            margin: 5px 0 15px 0;
            accent-color: var(--mck-blue);
        }

        button {
            background: var(--mck-blue);
            color: white;
            border: none;
            padding: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        button.reset { background: #f1f3f4; color: #333; margin-top: 10px; }

        /* SIMULATION CANVAS */
        .sim-container {
            position: relative;
            background: #fafafa;
            border: 1px solid var(--line-light);
            display: flex;
            flex-direction: column;
        }

        canvas {
            width: 100%;
            height: 400px;
            border-bottom: 1px solid var(--line-light);
        }

        .analysis-panel {
            flex-grow: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .insight-box {
            font-size: 13px;
            line-height: 1.5;
            color: #333;
        }
        .insight-box strong { color: var(--mck-blue); }
        
        .legend {
            display: flex;
            gap: 15px;
            font-size: 10px;
            margin-top: 10px;
            color: var(--text-sub);
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }

    </style>
</head>
<body>

<div class="header">
    <div class="title">
        <span>Operations Strategy Practice</span>
        <h1>Constraint Solver v1.0</h1>
    </div>
    <div class="kpi-row">
        <div class="kpi">
            <div class="kpi-val" id="dispThroughput">0</div>
            <div class="kpi-lbl">Units / Hour</div>
        </div>
        <div class="kpi">
            <div class="kpi-val" id="dispOEE">0%</div>
            <div class="kpi-lbl">System OEE</div>
        </div>
        <div class="kpi">
            <div class="kpi-val" id="dispWIP">0</div>
            <div class="kpi-lbl">Avg WIP</div>
        </div>
    </div>
</div>

<div class="stage">
    
    <div class="controls">
        <div class="insight-box" style="margin-bottom: 20px; font-style: italic; color: #555;">
            "Average capacity lies. Variance kills."<br>
            <span style="font-size: 10px; color: #999;">Adjust variability (Sigma) to see how lines fail even when average speed is balanced.</span>
        </div>

        <div class="control-group">
            <div class="group-header">STATION 1 (Feeder)</div>
            <div class="slider-row"><label>Avg Cycle Time (sec)</label><span class="val-disp" id="v_ct1">3.0</span></div>
            <input type="range" min="1.0" max="10.0" step="0.1" value="3.0" oninput="updateParam(0, 'mean', this.value)">
            
            <div class="slider-row"><label>Variance (Sigma)</label><span class="val-disp" id="v_sig1">0.5</span></div>
            <input type="range" min="0.0" max="3.0" step="0.1" value="0.5" oninput="updateParam(0, 'sigma', this.value)">
        </div>

        <div class="control-group">
            <div class="group-header">STATION 2 (Process)</div>
            <div class="slider-row"><label>Avg Cycle Time (sec)</label><span class="val-disp" id="v_ct2">3.2</span></div>
            <input type="range" min="1.0" max="10.0" step="0.1" value="3.2" oninput="updateParam(1, 'mean', this.value)">
            
            <div class="slider-row"><label>Variance (Sigma)</label><span class="val-disp" id="v_sig2">1.5</span></div>
            <input type="range" min="0.0" max="3.0" step="0.1" value="1.5" oninput="updateParam(1, 'sigma', this.value)">
        </div>

        <div class="control-group">
            <div class="group-header">BUFFER (Between 2 & 3)</div>
            <div class="slider-row"><label>Max Capacity</label><span class="val-disp" id="v_buf">5</span></div>
            <input type="range" min="0" max="50" step="1" value="5" oninput="updateBuffer(this.value)">
        </div>

        <div class="control-group">
            <div class="group-header">STATION 3 (Bottleneck?)</div>
            <div class="slider-row"><label>Avg Cycle Time (sec)</label><span class="val-disp" id="v_ct3">3.0</span></div>
            <input type="range" min="1.0" max="10.0" step="0.1" value="3.0" oninput="updateParam(2, 'mean', this.value)">
            
            <div class="slider-row"><label>Variance (Sigma)</label><span class="val-disp" id="v_sig3">0.2</span></div>
            <input type="range" min="0.0" max="3.0" step="0.1" value="0.2" oninput="updateParam(2, 'sigma', this.value)">
        </div>

        <button onclick="toggleSim()" id="btnToggle">Pause Simulation</button>
        <button class="reset" onclick="resetSim()">Reset Data</button>
    </div>

    <div class="sim-container">
        <canvas id="simCanvas"></canvas>
        <div class="legend">
            <div style="display:flex; align-items:center"><span class="dot" style="background:#188038; margin-right:5px;"></span> Running</div>
            <div style="display:flex; align-items:center"><span class="dot" style="background:#f9ab00; margin-right:5px;"></span> Starved (No Input)</div>
            <div style="display:flex; align-items:center"><span class="dot" style="background:#d93025; margin-right:5px;"></span> Blocked (Output Full)</div>
        </div>
        
        <div class="analysis-panel">
            <div class="insight-box">
                <div style="font-weight:bold; font-size:11px; color:#999; text-transform:uppercase; margin-bottom:5px;">System Diagnostic</div>
                <div id="textInsight">Initializing...</div>
            </div>
            <div class="insight-box">
                <div style="font-weight:bold; font-size:11px; color:#999; text-transform:uppercase; margin-bottom:5px;">Loss Waterfall</div>
                <div id="lossWaterfall" style="font-family: monospace; font-size:11px;">
                    Theoretical Max: <span id="theoMax">--</span><br>
                    Starvation Loss: <span id="starveLoss" style="color:#d93025">--</span><br>
                    Blocking Loss:   <span id="blockLoss" style="color:#d93025">--</span><br>
                    <strong>Actual Output: <span id="actualOut">--</span></strong>
                </div>
            </div>
        </div>
    </div>

</div>

<script>
    // --- SIMULATION ENGINE ---

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // Fit canvas to container
    function resize() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Configuration
    const STATIONS = [
        { id: 0, name: "Feed", mean: 3.0, sigma: 0.5, state: 'idle', timer: 0, itemsProcessed: 0, starvedT: 0, blockedT: 0, totalT: 0 },
        { id: 1, name: "Mix",  mean: 3.2, sigma: 1.5, state: 'idle', timer: 0, itemsProcessed: 0, starvedT: 0, blockedT: 0, totalT: 0 },
        { id: 2, name: "Pack", mean: 3.0, sigma: 0.2, state: 'idle', timer: 0, itemsProcessed: 0, starvedT: 0, blockedT: 0, totalT: 0 }
    ];

    let BUFFERS = [0, 0]; // Buffer 0 (btw S1-S2), Buffer 1 (btw S2-S3)
    let BUFFER_CAPS = [Infinity, 5]; // Buffer 0 is infinite (raw material), Buffer 1 is user controlled

    // Sim State
    let lastTime = 0;
    let simRunning = true;
    let totalTime = 0;
    let particles = []; // Visual items moving

    // --- LOGIC ---

    // Box-Muller transform for normal distribution
    function getGaussian(mean, sigma) {
        let u = 0, v = 0;
        while(u === 0) u = Math.random(); 
        while(v === 0) v = Math.random();
        let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        let res = num * sigma + mean;
        return Math.max(0.1, res); // Clamp to positive
    }

    function updateParam(idx, type, val) {
        val = parseFloat(val);
        STATIONS[idx][type] = val;
        
        // Update labels
        if(type === 'mean') document.getElementById(`v_ct${idx+1}`).innerText = val.toFixed(1);
        if(type === 'sigma') document.getElementById(`v_sig1`.replace('1', idx+1)).innerText = val.toFixed(1);
    }

    function updateBuffer(val) {
        BUFFER_CAPS[1] = parseInt(val);
        document.getElementById('v_buf').innerText = val;
    }

    function toggleSim() {
        simRunning = !simRunning;
        document.getElementById('btnToggle').innerText = simRunning ? "Pause Simulation" : "Resume";
        if(simRunning) requestAnimationFrame(loop);
    }

    function resetSim() {
        STATIONS.forEach(s => {
            s.itemsProcessed = 0;
            s.starvedT = 0;
            s.blockedT = 0;
            s.totalT = 0;
            s.timer = 0;
            s.state = 'idle';
        });
        BUFFERS = [0, 0];
        particles = [];
        totalTime = 0;
        resize(); // clear canvas
    }

    function loop(timestamp) {
        if (!simRunning) return;
        
        const dt = (timestamp - lastTime) / 1000; // Delta time in seconds
        lastTime = timestamp;
        
        if (dt > 0.1) { requestAnimationFrame(loop); return; } // skip huge lag spikes

        // Speed up sim multiplier
        const SIM_SPEED = 5; 
        const step = dt * SIM_SPEED;
        totalTime += step;

        // --- UPDATE STATIONS ---
        
        // Station 1 (Source)
        // Always has input (Buffer 0 infinite). 
        // Can be blocked if Buffer 1 (target) is full? No, S1 feeds S2 directly via implied buffer. 
        // Let's model: S1 outputs to "Buffer 0" which is actually the Queue for S2.
        // Simplified: S1 -> Queue1 -> S2 -> Queue2 -> S3 -> Out
        
        // Refined Architecture:
        // S1 takes nothing, produces to Q1.
        // S2 takes from Q1, produces to Q2.
        // S3 takes from Q2, produces to Out.

        // Station 1 Logic
        let s1 = STATIONS[0];
        s1.totalT += step;
        if(s1.state === 'idle') {
            // Check Blocked: Is Q1 full? (Let's say Q1 is infinite for this demo to focus on Q2)
            // Start working
            s1.state = 'working';
            s1.timer = getGaussian(s1.mean, s1.sigma);
        } else if(s1.state === 'working') {
            s1.timer -= step;
            if(s1.timer <= 0) {
                // Finish
                BUFFERS[0]++; // Add to Queue 1
                s1.itemsProcessed++;
                spawnParticle(0);
                s1.state = 'idle';
            }
        }

        // Station 2 Logic
        let s2 = STATIONS[1];
        s2.totalT += step;
        if(s2.state === 'idle') {
            // Check Starved
            if(BUFFERS[0] > 0) {
                // Check Blocked: Is Q2 full?
                if(BUFFERS[1] < BUFFER_CAPS[1]) {
                    // Start
                    BUFFERS[0]--; // Consume
                    s2.state = 'working';
                    s2.timer = getGaussian(s2.mean, s2.sigma);
                } else {
                    s2.state = 'blocked';
                }
            } else {
                s2.state = 'starved';
            }
        } else if(s2.state === 'working') {
            s2.timer -= step;
            if(s2.timer <= 0) {
                // Check Blocked on Eject?
                if(BUFFERS[1] < BUFFER_CAPS[1]) {
                    BUFFERS[1]++;
                    s2.itemsProcessed++;
                    spawnParticle(1);
                    s2.state = 'idle';
                } else {
                    s2.state = 'blocked'; // Stuck holding part
                }
            }
        } else if(s2.state === 'blocked') {
            s2.blockedT += step;
            if(BUFFERS[1] < BUFFER_CAPS[1]) {
                if(s2.timer <= 0) { // Was holding finished part
                     BUFFERS[1]++;
                     s2.itemsProcessed++;
                     spawnParticle(1);
                     s2.state = 'idle';
                } else { // Was waiting to start
                     BUFFERS[0]--;
                     s2.state = 'working';
                     s2.timer = getGaussian(s2.mean, s2.sigma);
                }
            }
        } else if(s2.state === 'starved') {
            s2.starvedT += step;
            if(BUFFERS[0] > 0) s2.state = 'idle';
        }

        // Station 3 Logic
        let s3 = STATIONS[2];
        s3.totalT += step;
        if(s3.state === 'idle') {
            if(BUFFERS[1] > 0) {
                BUFFERS[1]--;
                s3.state = 'working';
                s3.timer = getGaussian(s3.mean, s3.sigma);
            } else {
                s3.state = 'starved';
            }
        } else if(s3.state === 'working') {
            s3.timer -= step;
            if(s3.timer <= 0) {
                s3.itemsProcessed++;
                spawnParticle(2);
                s3.state = 'idle';
            }
        } else if(s3.state === 'starved') {
            s3.starvedT += step;
            if(BUFFERS[1] > 0) s3.state = 'idle';
        }

        // --- DRAWING ---
        draw();
        updateMetrics();

        requestAnimationFrame(loop);
    }

    function spawnParticle(stageIdx) {
        // Visual candy
        let startX = 100 + (stageIdx * 300);
        particles.push({ x: startX, y: 200, stage: stageIdx, life: 1.0 });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw Connection Lines
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(100, 200);
        ctx.lineTo(700, 200);
        ctx.stroke();

        // Draw Stations
        STATIONS.forEach((s, i) => {
            let x = 100 + (i * 300);
            let y = 200;
            
            // Color based on state
            let color = '#ccc';
            if(s.state === 'working') color = '#188038'; // Green
            if(s.state === 'starved') color = '#f9ab00'; // Yellow
            if(s.state === 'blocked') color = '#d93025'; // Red
            
            // Machine Box
            ctx.fillStyle = color;
            ctx.fillRect(x - 40, y - 40, 80, 80);
            
            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(s.name, x, y + 5);
            
            // State Text
            ctx.font = '10px Arial';
            ctx.fillText(s.state.toUpperCase(), x, y + 25);
            
            // Stats
            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.fillText(`Prod: ${s.itemsProcessed}`, x, y + 60);
        });

        // Draw Buffers (Q1 is virtual/infinite, Q2 is visualized)
        // Q2 is between S2 (x=400) and S3 (x=700) -> x=550
        let bX = 550, bY = 200;
        
        // Buffer Container
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(bX - 30, bY - 30, 60, 60);
        
        // Buffer Fill
        let fillH = Math.min(BUFFERS[1], BUFFER_CAPS[1]) / Math.max(1, BUFFER_CAPS[1]);
        ctx.fillStyle = 'rgba(5, 28, 44, 0.2)';
        ctx.fillRect(bX - 30, bY + 30, 60, -60 * fillH);
        
        ctx.fillStyle = '#111';
        ctx.textAlign = 'center';
        ctx.fillText(`Buffer: ${BUFFERS[1]}/${BUFFER_CAPS[1]}`, bX, bY + 50);

        // Draw Particles
        particles.forEach((p, i) => {
            p.x += 5; // Move right
            p.life -= 0.02;
            
            ctx.fillStyle = `rgba(5, 28, 44, ${p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
            ctx.fill();
        });
        particles = particles.filter(p => p.life > 0);
    }

    function updateMetrics() {
        if(totalTime < 1) return;

        // KPI Calculations
        const throughput = (STATIONS[2].itemsProcessed / totalTime) * 3600; // Units per hour
        const theoreticalMax = (3600 / Math.max(STATIONS[0].mean, STATIONS[1].mean, STATIONS[2].mean));
        const oee = (throughput / theoreticalMax) * 100;

        document.getElementById('dispThroughput').innerText = throughput.toFixed(0);
        document.getElementById('dispOEE').innerText = oee.toFixed(1) + "%";
        document.getElementById('dispWIP').innerText = BUFFERS[1]; // Simplified WIP

        // Waterfall Logic
        document.getElementById('theoMax').innerText = theoreticalMax.toFixed(0) + " u/h";
        document.getElementById('actualOut').innerText = throughput.toFixed(0) + " u/h";
        
        // Insight Generation
        let insight = "";
        const s2 = STATIONS[1];
        const s3 = STATIONS[2];
        
        const s2BlockPct = (s2.blockedT / totalTime) * 100;
        const s3StarvePct = (s3.starvedT / totalTime) * 100;
        
        document.getElementById('starveLoss').innerText = "-" + ((s3StarvePct/100)*theoreticalMax).toFixed(0);
        document.getElementById('blockLoss').innerText = "-" + ((s2BlockPct/100)*theoreticalMax).toFixed(0);

        if (s3StarvePct > 20) {
            insight += "Station 3 is <strong>STARVED</strong> for " + s3StarvePct.toFixed(0) + "% of the time. ";
            if(s2.sigma > 1.0) {
                insight += "The culprit is <strong>High Variance</strong> at Station 2, not speed. <br><br>Recommendation: Increase Buffer capacity or reduce Station 2 sigma (standardize work).";
            } else {
                insight += "Station 2 is simply too slow (Cycle Time mismatch).";
            }
        } else if (s2BlockPct > 20) {
             insight += "Station 2 is <strong>BLOCKED</strong>. Station 3 is the clear bottleneck.";
        } else {
            insight += "System is running at near-optimal efficiency given constraints.";
        }

        document.getElementById('textInsight').innerHTML = insight;
    }

    // Init
    resize();
    requestAnimationFrame(loop);

</script>

</body>
</html>
